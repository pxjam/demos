{"version":3,"sources":["sphere3d.js"],"names":["PI","Math","display","r","point","color","vertexes","alpha","p","Point3D","x","cos","y","z","sin"],"mappings":";AAAA,IAAMA,EAAKC,KAAKD,GAEhB,SAASE,EAAQC,GACRC,KAAAA,MAAQ,GACRC,KAAAA,MAAQ,QACRF,KAAAA,OAAkB,IAANA,EAAqB,GAAOA,EACxCA,KAAAA,EAAkB,iBAANA,EAAkB,GAAOA,EACrCG,KAAAA,SAAW,EAEX,IAAA,IAAIC,EAAQ,EAAGA,GAAS,EAAIP,EAAIO,GAAS,IAAM,CAC5CC,IAAAA,EAAI,KAAKJ,MAAM,KAAKE,UAAY,IAAIG,QACxCD,EAAEE,EAAIT,KAAKU,IAAIJ,GAAS,KAAKJ,EAC7BK,EAAEI,EAAI,EACNJ,EAAEK,EAAIZ,KAAKa,IAAIP,GAAS,KAAKJ,EACxBG,KAAAA","file":"sphere3d.f5ae31af.js","sourceRoot":"..\\..\\elcom","sourcesContent":["const PI = Math.PI\n\nfunction display(r) {\n    this.point = [];\n    this.color = \"blue)\"\n    this.r = (typeof(r) == \"undefined\") ? 20.0 : r;\n    this.r = (typeof(r) != \"number\") ? 20.0 : r;\n    this.vertexes = 0;\n\n    for (let alpha = 0; alpha <= 2 * PI; alpha += 0.17) {\n        let p = this.point[this.vertexes] = new Point3D();\n        p.x = Math.cos(alpha) * this.r;\n        p.y = 0;\n        p.z = Math.sin(alpha) * this.r;\n        this.vertexes++;\n    }\n}\n\n// let canvas = document.querySelector(\"[data-canvas]\")\n// let width = canvas.width\n// let height = canvas.height\n// let ctx = canvas.getContext('2d')\n//\n// let sphere = new Sphere3D()\n// let rotation = new Point3D()\n// let distance = 1000\n// let lastX = -1\n// let lastY = -1\n//\n// rotation.x = Math.PI / 10\n//\n// function Point3D() {\n//     this.x = 0\n//     this.y = 0\n//     this.z = 0\n// }\n//\n// function Sphere3D(radius) {\n//     this.vertices = new Array()\n//     this.radius = (typeof (radius) == \"undefined\" || typeof (radius) != \"number\") ? 20.0 : radius\n//     this.rings = 16\n//     this.slices = 32\n//     this.numberOfVertices = 0\n//\n//     let M_PI_2 = Math.PI / 2\n//     let dTheta = (Math.PI * 2) / this.slices\n//     let dPhi = Math.PI / this.rings\n//\n//     // Iterate over latitudes (rings)\n//     for (let lat = 0; lat < this.rings + 1; ++lat) {\n//         let phi = M_PI_2 - lat * dPhi\n//         let cosPhi = Math.cos(phi)\n//         let sinPhi = Math.sin(phi)\n//\n//         // Iterate over longitudes (slices)\n//         for (let lon = 0; lon < this.slices + 1; ++lon) {\n//             let theta = lon * dTheta\n//             let cosTheta = Math.cos(theta)\n//             let sinTheta = Math.sin(theta)\n//             p = this.vertices[this.numberOfVertices] = new Point3D()\n//\n//             p.x = this.radius * cosTheta * cosPhi\n//             p.y = this.radius * sinPhi\n//             p.z = this.radius * sinTheta * cosPhi\n//             this.numberOfVertices++\n//         }\n//     }\n// }\n//\n// function rotateX(point, radians) {\n//     let y = point.y\n//     point.y = (y * Math.cos(radians)) + (point.z * Math.sin(radians) * -1.0)\n//     point.z = (y * Math.sin(radians)) + (point.z * Math.cos(radians))\n// }\n//\n// function rotateY(point, radians) {\n//     let x = point.x\n//     point.x = (x * Math.cos(radians)) + (point.z * Math.sin(radians) * -1.0)\n//     point.z = (x * Math.sin(radians)) + (point.z * Math.cos(radians))\n// }\n//\n// function rotateZ(point, radians) {\n//     let x = point.x\n//     point.x = (x * Math.cos(radians)) + (point.y * Math.sin(radians) * -1.0)\n//     point.y = (x * Math.sin(radians)) + (point.y * Math.cos(radians))\n// }\n//\n// function projection(xy, z, xyOffset, zOffset, distance) {\n//     return ((distance * xy) / (z - zOffset)) + xyOffset\n// }\n//\n// function strokeSegment(index, ctx, width, height) {\n//     let x, y\n//     let p = sphere.vertices[index]\n//\n//     rotateX(p, rotation.x)\n//     rotateY(p, rotation.y)\n//     rotateZ(p, rotation.z)\n//\n//     x = projection(p.x, p.z, width / 2.0, 100.0, distance)\n//     y = projection(p.y, p.z, height / 2.0, 100.0, distance)\n//\n//     if (lastX == -1 && lastY == -1) {\n//         lastX = x\n//         lastY = y\n//         return\n//     }\n//\n//     if (x >= 0 && x < width && y >= 0 && y < height) {\n//         if (p.z < 0) {\n//             ctx.strokeStyle = \"gray\"\n//         } else {\n//             ctx.strokeStyle = \"black\"\n//         }\n//         ctx.beginPath()\n//         ctx.moveTo(lastX, lastY)\n//         ctx.lineTo(x, y)\n//         ctx.stroke()\n//         ctx.closePath()\n//         lastX = x\n//         lastY = y\n//     }\n// }\n//\n// function render() {\n//     let p = new Point3D()\n//     ctx.fillStyle = \"transparent\"\n//\n//     ctx.clearRect(0, 0, width, height)\n//     ctx.fillRect(0, 0, width, height)\n//\n//     // draw each vertex to get the first sphere skeleton\n//     for (i = 0; i < sphere.numberOfVertices; i++) {\n//         strokeSegment(i, ctx, width, height)\n//     }\n//\n//     // now walk through rings to draw the slices\n//     for (i = 0; i < sphere.slices + 1; i++) {\n//         for (let j = 0; j < sphere.rings + 1; j++) {\n//             strokeSegment(i + (j * (sphere.slices + 1)), ctx, width, height)\n//         }\n//     }\n//\n//     rotation.x += Math.PI / 180.0\n//     rotation.y += Math.PI / 90.0\n//     rotation.z += Math.PI / 90.0\n//\n//     // set distance to 0 and enable this to get a zoom in animation\n//     /*if(distance < 1000) {\n//         distance += 10;\n//       } */\n// }\n//\n// render()\n\n\n"]}